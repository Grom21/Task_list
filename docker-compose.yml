version: '3'
#version: '3' - указываем версию docker compose
services:
#  services: - указываем какие контейнеры нам нужно будет поднять.
  step:
#    step: - название первого контейнера с нашим бэкендом.
    image: step:0.0.2
#    image: step:0.0.2 - указываем название контейнера и его тэг (можно без тэга, тогда будет автоматически присвоен latest).
    build:
#      build: - указываем, что мы хотим его получить не скачивая с докер хаба, а будем "строить" на основании Dockerfile.
      context: .
#      context: . - указываем расположение Dockerfile, он у нас располагается в той же папке, что и docker-compose.yml
      dockerfile: Dockerfile
#      dockerfile: Dockerfile - указываем наименование Dockerfile
    ports:
      - "8080:8080"
#    здесь указываем первый порт - это внешний порт, с помощью которого мы можем получить доступ к нашему контейнеру, а второй порт - это внутренний порт контейнера.
    depends_on:
      - service-db
#    указываем, что наш контейнер должен подняться после того как поднимется контейнер с базой данных, так как, если контейнер с бэкендом поднимется первым и не будет доступа к базе данных, то он упадет с ошибкой.
    environment:
      - SERVER_PORT= 8080
      - SPRING_DATASOURCE_URL=jdbc:postgresql://service-db/postgres
#    указываем дополнительные настройки, в том числе url для подключения к базе данных. В этом пути мы уже используем внутреннее имя нашего контейнера с базой данных service-db.

  service-db:
    image: postgres:14.7-alpine
#  указываем имя нашего контейнера с базой данных, а также имя образа, который будет скачен с докер хаба. Желательно при этом указывать тэг образа, то есть версию, если версия не будет указана, то будет скачена и использована самая последняя версия данного образа, что может привести в будущем к несовместимости по версиям и ошибкам.
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: 123456
#    указываем username и password, они должны совпадать с теми, что мы указали в application.properties.
    ports:
      - "5432:5432"
#    указываем порты.
    volumes:
#      - ./infrastructure/db/create_db.sql:/docker-entrypoint-initdb.d/create_db.sql
      - db-data:/var/lib/postgresql/data
#    здесь мы указываем, чтобы выполнился наш скрипт, который мы написали ранее и который расположен в папке infrastructure/db по созданию базы данных books_db.
#    а во втором volume мы делаем чтобы наши данные сохранялись не локально в наш контейнер, а в файл, расположенный вне контейнера. Это нужно для того чтобы при перезапуске образа, если мы его удалим и поднимем снова, чтобы наши изменения в базе данных не потерялись, а сохранились
    restart: unless-stopped

volumes:
  db-data:

#спасибо автору за разъяснения инструкций docker и docker-compose: https://habr.com/ru/articles/735274/